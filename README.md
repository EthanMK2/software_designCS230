Operating platforms software design document I did for a class.
The client The Gaming Room wanted to develop a game application that is similar to the 1980s TV game Win, Lose, or Draw. The app renders images from a large library of images at a steady rate and are complete in 30 seconds. If a team does not guess the puzzle in time, the other teams have one guess each to solve it within 15 seconds. A game will have several teams, and multiple players on each team. Game and team names must be unique to be able to check whether a name is being used. Only a single instance of the game can exist in memory at a time.
A part I did well in this document was the UML domain model. I feel like I explained it comprehensively, and it all made sense to me how everything worked together to make the application work. 
A process that helped me understand as I developed the code was writing the structure down. I learn a lot more when I write down things, and so when I wrote down how to do the code, writing the code itself was easier. Another thing that helped me through this design doc was visualizing what each class contains. The UML is useful, but drawing my own picture of how a single game instance would look made it easier to notice the details and design requirements. 
One part I would revise in this doc would be the Evaluation section. I was not able to do good research on each platform, and finding the nuances of each platform was difficult. I think I could improve it by looking for books and design documents addressing the topic. 
How I interpreted the user's needs was placing myself in their shoes. I play video games myself, and so one of the major things I expect from a game application is smooth transition to each part of a game. In this case, that would probably be the game rounds where a new image is loaded into memory. So we would need to make sure the data is loaded in a way that is not intrusive, like loading 100MB of images every round causing delays. It is important to consider the user's needs in this way because it allows us as developers to make the most efficient and user-friendly experience possible, which is the goal after all. 
I approach software design by placing myself in the user's perspective and imagining how the code would work to meet that goal. I try to break down the problem as much as possible, and create code that first does the bare minimum in providing the service. Particularly, it is like creating an illusion of a feature by only including what is absolutely necessary for the user. Then, we can always complicate the code later if we need a complex solution to a problem.
